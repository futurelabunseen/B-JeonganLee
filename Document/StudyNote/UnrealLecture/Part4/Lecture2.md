# 2강: 게임플레이 어빌리티 시스템의 시작

- 강의 목표
  - 게임플레이 어빌리티 시스템 기본 설정 방법의 학습
    - 어빌리티시스템컴포넌트의 생성과 초기화
    - 게임플레이 어빌리티 제작과 활용
    - 게임플레이 태그의 활용
  - 다양한 구현 방법이 가진 장단점의 이해
- 강의 과제

## GAS

### 어빌리티 시스템 컴포넌트

- 줄여서 ASC(Ability System Component)라고 부름
- 게임플레이 어빌리티 시스템을 관리하는 핵심 컴포넌트 (Brain)
- 액터에 단 하나만 부착할 수 있다.
- 액터는 부착된 ASC를 통해 게임플레이 어빌리티를 발동시킬 수 있음
- ASC를 부착한 액터 사이에 GAS 시스템의 상호작용이 가능해진다.

### 게임플레이 어빌리티

- 줄여서 GA(Gameplay Ability)라고 부름
- ASC에 등록되어 발동시킬 수 있는 액션 명령으로 공격, 마법, 특수 공격등으로 나타낼 수 있고 이외에도 복잡한 액션이 가능하다.
- GA의 발동 과정
  - ASC에 어빌리티를 등록하고 ASC의 GiveAbility 함수에 발동할 GA의 **타입**을 전달한다.
    - 발동할 GA 타입 정보를 게임플레이 어빌리티 스펙이라고 한다.
  - ASC에게 어빌리티를 발동하라고 명령: ASC의 TryActivateAbility 함수에 발동할 GA의 **타입**을 전달한다.
    - ASC에 등록된 타입이면 GA의 인스턴스가 생성된다.
  - 발동된 GA에는 발동한 액터와 실행 정보가 기록된다.
    - SpecHandle: 발동된 어빌리티에 대한 핸들
    - ActorInfo: 어빌리티의 소유자와 아바타 정보
    - ActivationInfo: 발동 방식에 대한 정보
- GA의 주요 함수
  - CanActivateAbility: 어빌리티가 발동 가능한지 확인
  - ActivateAbility: 어빌리티가 발동될 때 호출
  - CancelAbility: 어빌리티가 취소될 때 호출
  - EndAbility: 어빌리티가 종료될 때 호출

이해한 바로는 하나의 델리게이트 관리자를 두고 이를 관리자가 호출함에 따라 자동으로 해당 객체의 함수를 호출하는 방식으로 보인다.

## 게임플레이 태그의 활용

### 게임플레이 태그

- FName으로 관리되는 경량의 표식 데이터
  - 액터나 컴포넌트에 지정했던 태그와 다른 데이터
- 프로젝트 설정에서 별도로 게임플레이 태그를 생성하고 관리할 수 있다.
  - 결과는 DefaultGameplayTags.ini 파일에 저장된다.
- 태그는 계층 구조로 관리되며, 태그의 계층 구조를 통해 태그를 관리할 수 있다.
- 게임플레이 태그들의 저장소 GamePlayTagContainer
  - 여러 개의 태그를 저장하고 관리하는 컨테이너
  - 태그를 추가하거나 제거할 수 있다.
  - 태그를 비교하거나 검색할 수 있다.
- 게임플레이 어빌리티 시스템과 독립적으로 사용 가능하다.

### 게임플레이 어빌리티와 게임플레이 태그

- 게임플레이 어빌리티에 부착한 태그
  - 어빌리티에 저장한 태그 (AbilityTags 태그 컨테이너)
- 게임플레이 어빌리티에 대해 다양한 실행 조건 설정

## 정리

- 액터의 회전을 3가지 방법으로 알아봄
  - 액터를 확장하여 구현하는 방법: 익숙한 방법으로 빠르다. 새로운 액터가 추가됨
  - GAS를 사용하여 구현: C++만 사용해 모든 기능 구현 가능, 액터로부터 기능 분리
  - 게임플레이 태그를 추가 활용해 구현: 의존성없는 설계가 가능
- 액터의 역할을 최소화시키는데 주력
- 게임플레이 태그를 활용해 의존성을 분리
- C++ 프로그래밍 없이도 태그 규약에 따라 유연하게 확장 가능

결국 액터의 기능을 최소화하여 담을 수 있는 기능만을 담고 가능한 행위는 GAS와 게임플레이 태그로 빼서 관리하는 방식이다.
