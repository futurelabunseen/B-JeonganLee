# 언리얼 엔진 5: 고급 사용자를 위한 청사진

모든 내용을 따라하여 진행하진 않고, 도움이 될만한 부분만 들으면서 따라함

다루는 내용은 다음과 같다.

- 캐스팅
- 블루프린트 인터페이스
- 캐스팅과 인터페이스 Reference Viewer
- 이벤트 틱
- 매크로
- 블루프린트 디버깅

## 정리

- 캐스팅은 참조를 생성하기 때문에 문제가 된다. 인터페이스는 아님
- 영상을 보다보니 이런 노드형식의 프로그래밍도 만약 코파일럿이나 AI쪽으로 지원이 된다면 활용성이 더 높아질 것 같다.
- Reference Viewer를 통해 참조를 확인할 수 있다. (대박신기)
  - 인터페이스의 이점은 이를 통해 확인 가능하다. 의존성이 낮아진다.
  - 캐스팅은 실제 뷰에서 강한 결합을 가진 것을 확인
- Size Map으로 실제 메모리 사용량을 확인할 수 있다. (이것도 대박 신기..)
  - 쉽게 의존성 전이가 발생하는 구간을 확인할 수 있다.
  - 오른쪽 위에서 `Disk`나 `Memory`를 선택하여 확인 가능
  - 메모리 뷰에 cast를 사용했기 때문에 메모리가 실제 런타임에 캐릭터마다 적재되는 것을 확인
  - ex) 쉽게 유도탄에서 cast를 사용한다면 100명의 캐릭터의 메모리값을 적재하게 된다. (매우 비효율적)
  - 예제는 간단한 문으로 보여주지만, 크 차이는 거의 10배 가까이 난다.
  - 이런 좋은 기능이 있다니... 충격적이다.. C++에서도 되는지 궁금하다.
  - 이건 블루프린트에만 해당되는 것이 아닌 C++에서도 주의해야 하는 부분이다.
- 결국 싱글톤을 사용하는 구조 -> 캐스트로 받아온다. 와 같이 의존성이 생기는 부분은 블루프린트로도 어쩔 수 없는 것, 본질적인 게임 구조, 객체지향은 알아야 하는 것 같다.
- 캐릭터에 인터페이스로 Getter로 만드는 부분은 인상적이다. 이런식으로 사용하면 블루프린트에서도 쉽게 사용할 수 있을 것 같다.
- 자동으로 NULL객체까지 오류 없이 처리해주는 부분..
- 틱이벤트는 Update와 마찬가지로 프레임마다 호출되는데, 그 값도 쉽게 조절 가능하다.
  - 조심해서 사용해야 함도 같고, 실제 엔진에서도 Tick을 많이 사용한다.
- 확실히 시각적인 타임라인, 시퀀스같은 부분은 블루프린트가 유용한 것 같다.
- 순수함수에 대한 캐싱 처리
- 블루프린트 매크로는 복사가 일어나기 때문에 지양하는 것이 좋을 것 같다.
- 블루프린트에서 디버깅은 해당 노드에 Break Point를 걸어서 확인할 수 있다.
